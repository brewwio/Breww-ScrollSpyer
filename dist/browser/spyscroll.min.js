var SpyScroll = (function () {
  'use strict';

  // _____   _____    _____   _          __  _          __
  // |  _  \ |  _  \  | ____| | |        / / | |        / /
  // | |_| | | |_| |  | |__   | |  __   / /  | |  __   / /
  // |  _  { |  _  /  |  __|  | | /  | / /   | | /  | / /
  // | |_| | | | \ \  | |___  | |/   |/ /    | |/   |/ /
  // |_____/ |_|  \_\ |_____| |___/|___/     |___/|___/
  //                                                    .io
  var SpyScroller = /** @class */ (function () {
      // Define a constructor for the SpyScroller class
      function SpyScroller(
      // The menu element or its selector that contains the menu items
      menu, 
      // The options object that configures the behavior of the SpyScroller instance (optional)
      options) {
          if (menu === void 0) { menu = "#navMenu"; }
          if (options === void 0) { options = {}; }
          var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
          this.isLastSection = false;
          // Set the options property by merging the default values with the provided options
          this.options = {
              sectionSelector: (_a = options.sectionSelector) !== null && _a !== void 0 ? _a : "section",
              targetSelector: (_b = options.targetSelector) !== null && _b !== void 0 ? _b : "[data-jump]",
              topOffset: Array.isArray(options.topOffset)
                  ? options.topOffset
                  : [{ topOffset: 500 }],
              activeClass: Array.isArray(options.activeClass)
                  ? options.activeClass
                  : ["active"],
              onLastScrollInView: (_c = options.onLastScrollInView) !== null && _c !== void 0 ? _c : null,
              onFirstScrollInView: (_d = options.onFirstScrollInView) !== null && _d !== void 0 ? _d : null,
              onSectionChange: (_e = options.onSectionChange) !== null && _e !== void 0 ? _e : null,
              onScroll: (_f = options.onScroll) !== null && _f !== void 0 ? _f : null,
              animation: {
                  animType: (_h = (_g = options.animation) === null || _g === void 0 ? void 0 : _g.animType) !== null && _h !== void 0 ? _h : "attribute",
                  enabled: (_k = (_j = options.animation) === null || _j === void 0 ? void 0 : _j.enabled) !== null && _k !== void 0 ? _k : false,
              },
              easing: {
                  enabled: (_m = (_l = options.easing) === null || _l === void 0 ? void 0 : _l.enabled) !== null && _m !== void 0 ? _m : false,
                  type: (_p = (_o = options.easing) === null || _o === void 0 ? void 0 : _o.type) !== null && _p !== void 0 ? _p : "",
              },
          };
          if (!menu) {
              throw new Error("First argument cannot be empty");
          }
          if (!(typeof menu === "string" || menu instanceof HTMLElement)) {
              throw new TypeError("menu can be either string or an instance of HTMLElement");
          }
          if (typeof options !== "object") {
              throw new TypeError("options can only be of type object");
          }
          if (typeof options.targetSelector !== "string") {
              throw new TypeError("targetSelector can only be of type string");
          }
          if (options.targetSelector == "") {
              throw new TypeError("targetSelector can not be empty");
          }
          if (typeof this.options.animation !== "object") {
              throw new TypeError("animation in options can only be of type object");
          }
          this.menuList =
              menu instanceof HTMLElement ? menu : document.querySelector(menu);
          this.Navmenu =
              menu instanceof HTMLElement ? menu : document.querySelector(menu);
          if (!this.menuList) {
              throw new Error("No menu element found for selector \"".concat(menu, "\""));
          }
          this.sections = document.querySelectorAll(this.options.sectionSelector);
          this.boundOnScroll = this.onScroll.bind(this);
          this.bind();
          if (this.options.easing.enabled)
              this.easing();
      }
      /**
       * Applies easing to the menu items based on the selected target.
       * If the target selector is "[data-jump]", it adds click event listeners to each menu item with the target selector,
       * retrieves the target element using the data-jump attribute, and scrolls to the target element using the specified easing type.
       * If the target selector is different[HREF], it adds click event listeners to each menu item with the target selector,
       * retrieves the target element using the item's href attribute, and scrolls to the target element using the specified easing type.
       *
       * @private
       * @function easing
       * @return {void}
       * @since 1.0.0
       */
      SpyScroller.prototype.easing = function () {
          var _this = this;
          if (this.options.targetSelector === "[data-jump]") {
              this.menuList
                  .querySelectorAll(this.options.targetSelector)
                  .forEach(function (item) {
                  item.addEventListener("click", function (event) {
                      var target = event.target.closest("[data-jump]");
                      if (!target)
                          return;
                      event.preventDefault();
                      var refId = target.getAttribute("data-jump");
                      _this.scrollTo(document.getElementById(refId), 1000, _this.options.easing.type);
                  });
              });
          }
          else {
              this.menuList
                  .querySelectorAll(this.options.targetSelector)
                  .forEach(function (item) {
                  item.addEventListener("click", function (event) {
                      event.preventDefault();
                      // console.log(item.getAttribute("href").replace("#", ""));
                      _this.scrollTo(document.getElementById(item.getAttribute("href").replace("#", "")), 1000, _this.options.easing.type);
                  });
              });
          }
      };
      /**
       * Scrolls the window to a specified target element using the provided duration and easing function.
       *
       * @private
       * @function scrollTo
       * @param {HTMLElement} target - The target element to scroll to.
       * @param {number} duration - The duration of the scrolling animation in milliseconds.
       * @param {any} easing - The easing function to apply during the scrolling animation.
       * @return {void}
       * @since 1.0.0
       */
      SpyScroller.prototype.scrollTo = function (target, duration, easing) {
          var start = window.pageYOffset;
          var startTime = "now" in window.performance ? performance.now() : new Date().getTime();
          var documentHeight = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight);
          var windowHeight = window.innerHeight ||
              document.documentElement.clientHeight ||
              document.getElementsByTagName("body")[0].clientHeight;
          var destinationOffset = typeof target === "number" ? target : target.offsetTop;
          var destinationOffsetToScroll = Math.round(documentHeight - destinationOffset < windowHeight
              ? documentHeight - windowHeight
              : destinationOffset);
          if ("requestAnimationFrame" in window === false) {
              window.scroll(0, destinationOffsetToScroll);
              return;
          }
          function scroll() {
              var now = "now" in window.performance ? performance.now() : new Date().getTime();
              var elapsed = now - startTime;
              var time = Math.min(1, elapsed / duration);
              var startValue = 0; // Adjust this value according to your needs
              var amountOfChange = 1; // Adjust this value according to your needs
              var timeFunction = easing(time, startValue, amountOfChange, 1);
              window.scroll(0, Math.ceil(timeFunction * (destinationOffsetToScroll - start) + start));
              if (window.pageYOffset === destinationOffsetToScroll ||
                  elapsed > duration) {
                  return;
              }
              requestAnimationFrame(scroll);
          }
          scroll();
      };
      /**
       * Retrieves the currently active section based on the current scroll position.
       *
       * @private
       * @function currentActiveSection
       * @returns {HTMLElement | undefined} - The currently active section element, or undefined if no section is active.
       * @since 1.0.0
       */
      SpyScroller.prototype.currentActiveSection = function () {
          var _this = this;
          var currentPosition = (document.documentElement.scrollTop || document.body.scrollTop) +
              this.getTopOffset();
          return Array.from(this.sections).find(function (section) {
              var startAt = _this.getOffset(section);
              var endAt = startAt + section.offsetHeight;
              return currentPosition >= startAt && currentPosition < endAt;
          });
      };
      /**
       * Retrieves the top offset value based on the current screen width and options configuration.
       *
       * @private
       * @function getTopOffset
       * @returns {number} - The top offset value to be used.
       * @since 1.0.0
       */
      SpyScroller.prototype.getTopOffset = function () {
          var screenWidth = window.innerWidth;
          var topOffset;
          // console.log(this.options.topOffset);
          if (Array.isArray(this.options.topOffset)) {
              for (var _i = 0, _a = this.options.topOffset; _i < _a.length; _i++) {
                  var option = _a[_i];
                  if ((!option.minWidth || screenWidth >= option.minWidth) &&
                      (!option.maxWidth || screenWidth <= option.maxWidth)) {
                      topOffset = option.topOffset;
                      break; // Added break statement to exit the loop once the matching option is found
                  }
              }
          }
          else if (typeof this.options.topOffset === "number") {
              topOffset = this.options.topOffset;
          }
          // console.log("topOffset: " + topOffset);
          return topOffset;
      };
      /**
       * Retrieves the offset position of the specified element relative to its offset parent.
       *
       * @private
       * @function getOffset
       * @param {HTMLElement} element - The element for which to retrieve the offset position.
       * @param {boolean} horizontal - Optional. Indicates whether to retrieve the horizontal offset (default: false).
       * @returns {number} - The offset position of the element.
       * @since 1.0.0
       */
      SpyScroller.prototype.getOffset = function (element, horizontal) {
          if (horizontal === void 0) { horizontal = false; }
          if (!element) {
              return 0;
          }
          var parentElement = element.offsetParent;
          return (this.getOffset(parentElement, horizontal) +
              (horizontal ? element.offsetLeft : element.offsetTop));
      };
      /**
       * Retrieves the active menu item information based on the specified section element.
       *
       * @private
       * @function getActiveMenuItem
       * @param {HTMLElement} section - The section element for which to retrieve the active menu item.
       * @returns {Object | undefined} - The active menu item information, including sectionId, element, isLastSection, and isFirstSection. Returns undefined if the section is not valid.
       * @since 1.0.0
       */
      SpyScroller.prototype.getActiveMenuItem = function (section) {
          if (!section) {
              return;
          }
          var isLastSection = false;
          var isFirstSection = false;
          var sectionId = section.getAttribute("id");
          var attribute = this.options.targetSelector;
          if (this.options.targetSelector === "[data-jump]") {
              attribute = "data-jump";
              var items = document.querySelectorAll("[".concat(attribute, "]"));
              var element = Array.from(items).find(function (item) { return item.getAttribute(attribute) === sectionId; });
              var index = Array.from(items).indexOf(element);
              if (Array.from(items).indexOf(element) === 0) {
                  isFirstSection = true;
              }
              else if (index === items.length - 1) {
                  isLastSection = true;
              }
              return {
                  sectionId: sectionId,
                  element: element,
                  isFirstSection: isFirstSection,
                  isLastSection: isLastSection,
              };
          }
          else {
              var element_1 = this.menuList.querySelector("[href=\"#".concat(sectionId, "\"]"));
              var menuItems = Array.from(this.menuList.querySelectorAll('[href^="#"]'));
              var index = menuItems.findIndex(function (item) { return item === element_1; });
              if (index == 0)
                  isFirstSection = true;
              if (menuItems.length - 1 == index)
                  isLastSection = true;
              return {
                  sectionId: sectionId,
                  element: element_1,
                  isFirstSection: isFirstSection,
                  isLastSection: isLastSection,
              };
          }
      };
      /**
       * Removes the active class from all menu links, except for the specified element to ignore.
       *
       * @private
       * @function removeActiveLink
       * @param {Object} options - Optional. An object containing additional options.
       * @param {HTMLAnchorElement} options.ignore - Optional. The menu link element to ignore and not remove the active class from.
       * @returns {void}
       * @since 1.0.0
       */
      SpyScroller.prototype.removeActiveLink = function (options) {
          var _this = this;
          this.menuList
              .querySelectorAll(this.options.targetSelector)
              .forEach(function (item) {
              var _a;
              return (_a = item.classList).remove.apply(_a, _this.options.activeClass);
          });
      };
      /**
       * Checks and updates the active state of a menu link based on the provided menu item element.
       *
       * @private
       * @function ActiveLinkChecker
       * @param {HTMLAnchorElement} menuItem - The menu item element to check and update the active state for.
       * @returns {void}
       * @since 1.0.0
       */
      SpyScroller.prototype.ActiveLinkChecker = function (menuItem) {
          var _a;
          if (menuItem.matches(this.options.targetSelector) &&
              !this.options.activeClass.some(function (className) {
                  return menuItem.classList.contains(className);
              })) {
              (_a = menuItem.classList).add.apply(_a, this.options.activeClass);
              this.handleSubmenu(menuItem);
          }
          menuItem.scrollIntoView({ behavior: "smooth" }); // scroll the menuItem into view with smooth behavior
      };
      /**
       * Handles the submenu behavior for a given menu item by adding the active class to its parent list item if applicable.
       *
       * @private
       * @function handleSubmenu
       * @param {HTMLAnchorElement} menuItem - The menu item element for which to handle the submenu behavior.
       * @returns {boolean} - Indicates whether the submenu was successfully handled and the active class was added to the parent list item.
       * @since 1.0.0
       */
      SpyScroller.prototype.handleSubmenu = function (menuItem) {
          var _a;
          var parentLi = menuItem.closest("li");
          if (parentLi) {
              var parentUl = parentLi.closest("ul");
              if (parentUl && parentUl.closest("li")) {
                  var parentLi_1 = parentUl.closest("li");
                  if (parentLi_1) {
                      (_a = parentLi_1.classList).add.apply(_a, this.options.activeClass);
                      return true;
                  }
              }
          }
          return false;
      };
      /**
       * Perform actions based on the current scroll position and the active section and menu item.
       * @returns void
       * @since Version 1.0.0
       */
      SpyScroller.prototype.onScroll = function () {
          var section = this.currentActiveSection();
          if (this.options.onScroll)
              this.executeonScroll(section, this.sections);
          if (this.lastActiveSection == section)
              return;
          this.lastActiveSection = section;
          if (this.options.onSectionChange)
              this.executeSectionChanged(section, this.sections);
          var activeMenuItem = this.getActiveMenuItem(section);
          activeMenuItem.sectionId;
          var menuItem = activeMenuItem.element;
          //if (this.options.animation.enabled) BrewwAnimationHandlerObj.animateInitiater(this.options.animation,section,this.sections,this.options.animationType);
          if (menuItem) {
              this.removeActiveLink({ ignore: menuItem });
              this.ActiveLinkChecker(menuItem);
          }
          if (this.options.onLastScrollInView) {
              if (activeMenuItem.isLastSection)
                  this.options.onLastScrollInView();
          }
          if (this.options.onFirstScrollInView) {
              if (activeMenuItem.isFirstSection)
                  this.options.onFirstScrollInView();
          }
      };
      SpyScroller.prototype.executeSectionChanged = function (section, sections) {
          this.options.onSectionChange(section, sections, this.options.animation);
      };
      SpyScroller.prototype.executeonScroll = function (section, sections) {
          this.options.onScroll(section, sections, this.options.animation);
      };
      /**
       * Method open To All
       * Add an event listener to the window object that calls the boundOnScroll and onSectionScroll methods when the user scrolls.
       * @returns void
       * @since Version 1.0.0
       */
      SpyScroller.prototype.bind = function () {
          this.boundOnScroll = this.onScroll.bind(this);
          window.addEventListener("scroll", this.boundOnScroll);
      };
      /**
       * Remove the event listener from the window object that was added by the bind method.
       * @returns void
       * @since Version 1.0.0
       */
      SpyScroller.prototype.unbind = function () {
          window.removeEventListener("scroll", this.boundOnScroll);
          this.boundOnScroll = null;
      };
      /**
       * Retrieves information about the current active section.
       *
       * @public
       * @function getCurrentSection
       * @param {boolean} isChild - Optional. Specifies whether to include information about child elements of the current section. Default is false.
       * @returns {Object} - An object containing information about the current active section.
       * @since 1.0.0
       */
      SpyScroller.prototype.getCurrentSection = function (isChild) {
          if (isChild === void 0) { isChild = false; }
          var childObject = null;
          if (isChild)
              childObject = this.currentSectionChild();
          var sectioninfo = {
              currentActiveSectionElement: this.currentActiveSection(),
              currentActiveSectionIndex: Array.from(this.sections).indexOf(this.currentActiveSection()),
              currentSectionId: this.currentActiveSection().getAttribute("id"),
              currentSectionDataList: this.currentActiveSection().attributes,
              currentSectionClassList: this.currentActiveSection().classList,
              currentSectionChildElementCount: this.currentActiveSection().childElementCount,
              currentSectionFirstChild: this.currentActiveSection().firstElementChild,
              currentSectionLastChild: this.currentActiveSection().lastElementChild,
              currentSectiionChildElementNclass: childObject,
          };
          return sectioninfo;
      };
      /**
       * Retrieves information about the child elements of the current active section.
       *
       * @private
       * @function currentSectionChild
       * @returns {Array} - An array of objects containing information about the child elements of the current active section.
       * @since 1.0.0
       */
      SpyScroller.prototype.currentSectionChild = function () {
          var children = this.currentActiveSection().children;
          for (var i = 0; i < children.length; i++) {
              var child = children[i];
              var attributes = {};
              for (var j = 0; j < child.attributes.length; j++) {
                  var attribute = child.attributes[j];
                  attributes[attribute.name] = attribute.value;
              }
              var classes = Array.from(child.classList);
              ({ tag: child.tagName, attributes: attributes, classes: classes });
          }
      };
      return SpyScroller;
  }());

  return SpyScroller;

})();
